import itertools
import numpy as np
import time
import matplotlib.pyplot as plt
from classifiers import Storage, SVM

def hyperparameter_tuning(storage, hyperparams_grid):
    '''
    Tries each combination of parameters to see which one gets the best results
    @param:
        storage: storage object with samples
        hyperparams_grid: grid with all the values to be tested 
        
    @returns:
        list of results containing epochs, lr, c, accuracy and training time
    '''
    # Create a list with all the possible hyperparameters
    hyperparam_combinations = list(itertools.product(
        hyperparams_grid['epochs'],
        hyperparams_grid['lr'],
        hyperparams_grid['c']
    ))
    
    # List for keeping the results
    results = []
    
    # Calculate the total combinations and start the counter for current combinations
    total_combinations = len(hyperparam_combinations)
    current_combination = 1
    
    training_percentage = 0.8 # Percentage of samples to be used in training
    
    # For each epoch, lr and c combination, create a test SVM and record the accuracy and training time
    for epochs, lr, c in itertools.product(hyperparams_grid['epochs'], hyperparams_grid['lr'], hyperparams_grid['c']):
        remaining = total_combinations - current_combination
        print(f"Testing combination {current_combination}/{total_combinations} " f"(remaining: {remaining}). Epochs: {epochs}, LR: {lr}, C: {c}")
        
        # Make a test instance of the SVM with the current loop of hyperparameters
        test_instance = SVM(storage, 'malware', 'benign', training_percentage, e=epochs, lr=lr, c=c)
        
        # Start of training
        start_time = time.time()
        
        test_instance.train(e=epochs, lr=lr, c=c)
        training_time = time.time() - start_time
        
        # Test the SVM 
        accuracy = test_instance.test()
        
        # Add this round of results to the final tally
        results.append({
            'epochs': epochs,
            'lr': lr,
            'c': c,
            'accuracy': accuracy,
            'training_time': training_time
        })
        
        current_combination += 1
        
    return results
    
def plot_best_parameters(results, hyperparams_grid):
    """
    Aggregates results to find the maximum accuracy for each hyperparameter value,
    and then plots these as separate curves.
    
    @param:
        results: list with dictionaries of results
        hyperparams_grid: grid with all the values that were tested 
    """
    # For each value of epochs, find the best accuracy.
    best_epochs = {}
    for e in hyperparams_grid['epochs']:
        subset = [r for r in results if r['epochs'] == e]
        if subset:
            best_epochs[e] = max(r['accuracy'] for r in subset)
    
    # For each value of learning rate, find the best accuracy.
    best_lr = {}
    for lr in hyperparams_grid['lr']:
        subset = [r for r in results if r['lr'] == lr]
        if subset:
            best_lr[lr] = max(r['accuracy'] for r in subset)
    
    # For each value of regularization parameter, find the best accuracy.
    best_c = {}
    for c in hyperparams_grid['c']:
        subset = [r for r in results if r['c'] == c]
        if subset:
            best_c[c] = max(r['accuracy'] for r in subset)
    
    # Plotting Best Accuracy vs. Epochs
    plt.figure()
    plt.plot(list(best_epochs.keys()), list(best_epochs.values()), marker='o')
    plt.xlabel('Epochs')
    plt.ylabel('Max Accuracy')
    plt.title('Max Accuracy vs. Epochs')
    plt.grid(True)

    # Plotting Best Accuracy vs. Learning Rate
    plt.figure()
    plt.plot(list(best_lr.keys()), list(best_lr.values()), marker='o')
    plt.xlabel('Learning Rate')
    plt.ylabel('Max Accuracy')
    plt.title('Max Accuracy vs. Learning Rate')
    plt.grid(True)

    # Plotting Best Accuracy vs. Regularization Parameter
    plt.figure()
    plt.plot(list(best_c.keys()), list(best_c.values()), marker='o')
    plt.xlabel('Regularization Parameter (c)')
    plt.ylabel('Max Accuracy')
    plt.title('Max Accuracy vs. Regularization Parameter')
    plt.grid(True)

    plt.show()
    
    
def main():
    # Make the data storage class
    storage = Storage("malware_classification/corpus/feature_vectors.zip", "malware_classification/corpus/sha256_family.csv", benign_max=600, malware_max=500)
    
    # Define the hyperparameter grid with specified ranges:
    hyperparams_grid = {
        'epochs': list(range(5, 16)),  # Integers from 5 to 15 inclusive.
        'lr': sorted([0.1, 0.2, 0.3, 0.4, 0.5, 0.01, 0.02, 0.03, 0.04, 0.05]),  # Combined sorted learning rates.
        'c': [0.01, 0.02, 0.03]  # Values from 0.010 to 0.030 inclusive.
    }
    
    # Run the hyperparameter tuning 
    results = hyperparameter_tuning(storage, hyperparams_grid)
    
    # Plot the results to find the best of each parameter
    plot_best_parameters(results, hyperparams_grid)
    
if __name__ == "__main__":
    main()
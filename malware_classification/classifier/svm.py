import logging
import zipfile
from functools import cached_property
import torch
import csv

logging.basicConfig(
    level=logging.DEBUG,
    format = '%(asctime)s - %(message)s'
)

logger = logging.getLogger(__name__)
logging.disable(50)

class _Algorithm():
    '''
    Generic methods and constructors for ML algorithms
    '''

    def __init__(self, data: list, feature_data: list) -> None:
        self.data = data[0]
        self.feature_data = feature_data[0]

        self.features = self.get_features()
        self.labels, self.sample_names = self.get_labels()
        self.feature_vectors = self.get_feature_vectors()
        
        # I was so curious in the purpose of this I decided to keep it
        _ = self.feature_vectors

    # TODO make a Sample class for storing and retrieving sample info easily 

    @cached_property
    def get_labels(self):
        '''
        Returns a tuple - (list of labels, list of sample names)
        +1 for malware, -1 for benign
        '''
        labels = []
        sample_names = []
        with zipfile.ZipFile(self.feature_data, 'r') as f:
            for sample in f.namelist():
                sample_names.append(sample)
                if sample in self.malware_labels:
                    labels.append(1)
                else:
                    labels.append(-1)
        return labels, sample_names

    @cached_property
    def get_features(self):
        features = set()
        with zipfile.ZipFile(self.feature_data, 'r') as f:
            for feature_file in f.namelist():
                with f.open(feature_file) as ff:
                    content = ff.read()
                    features.add(content)

        # let's use logging since we import it anyway
        print(f"Number of features: {len(features)}")
        return features

    @cached_property
    def get_feature_vectors(self) -> dict:
        '''
        Returns a dictionary that maps sample names to feature vectors
        where 1 = presence of feature, 0 = no feature
        '''
        vectors = {}

        with zipfile.ZipFile(self.feature_data, 'r') as f:
            for sample in f.namelist():
                with f.open(sample) as s:
                    content = s.read()
                    vector = {}
                    for feature in self.features:
                        if feature in content:
                            vector[feature] = 1
                        else:
                            vector[feature] = 0
                    vectors[sample] = vector
        return vectors
    
    @cached_property
    def get_malware_labels(self):
        '''
        Returns a dictionary {sample_hash:malware_type} (str:str)
        '''
        labels_dict = {}
        with open(self.data, newline='') as csvfile:
            reader = csv.reader(csvfile)
            for row in reader:
                sample_hash = row[0]
                labels_dict[sample_hash] = row[1]
        return labels_dict

class SVM(_Algorithm):
    '''
    Support Vector Machine Algorithm
    Performs Binary Classification - benign samples are -1 and malware is +1
    '''
    def __init__(self, *args, **kwargs) -> None:
        super(SVM, self).__init__(*args, **kwargs)
        self.name = "Support Vector Machine"
        self.X, self.y = self.prepare_data()
        self.train_model()
        self.evaluate()

    @cached_property
    def prepare_data(self):
        '''
        Returns tuple - x tensor, y tensor
        Converts the feature vectors into a tensor
        '''
        feature_list = sorted(list(self.features))
        X_list = []
        for sample in self.sample_names:
            vector = self.feature_vectors[sample]
            row = []
            for feature in feature_list:
                row.append(vector[feature])
            X_list.append(row)
        X_tensor = torch.tensor(X_list, dtype=torch.float32)
        y_tensor = torch.tensor(self.labels, dtype=torch.float32)
        return X_tensor, y_tensor
    
    def train_model(self):
        '''
        Train model utilizing Stochastic Gradient Descent with Hinge Loss
        '''
        pass

    def evaluate(self):
        '''
        Evaluate the SVM using the training data
        '''
        pass
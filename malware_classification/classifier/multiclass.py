# AI Usage Statement
# Tools Used: GitHub Copilot

# Usage: Cropping a numpy array
# Verification: The array was cropped successfully

# Prohibited Use Compliance: Confirmed

import classifiers
import matplotlib.pyplot as plt
import numpy as np
from collections import Counter
from tqdm import tqdm
from itertools import combinations

class MultiClassClassifier:
    '''
    Class for Multi-Class classification.\n
    '''
    def __init__(self, storage: classifiers.Storage, model: classifiers.SVM, target_classes = [], training_percentage: float = 0.8, top_N = 20, *args, **kwargs):
        self.storage = storage
        self.model = model
        self.training_percentage = training_percentage
        self.top_N = top_N
        self.classifiers_dict = {}
        self.classifiers = []

        if not target_classes:
            self.target_classes = storage.possible_families_list
        else:
            self.target_classes = target_classes

    def train(self, **kwargs):
        '''
        Trains the model.\n
        '''
        raise NotImplementedError()


    def confusion_matrix(self):
        '''
        Creates a normalized confusion matrix.\n
        '''
        n_classes = len(self.target_classes)

        # create an index map
        family_to_idx = {family: idx for idx, family in enumerate(self.target_classes)}
        matrix = np.zeros((n_classes, n_classes))

        test_samples = []
        for classifiers in self.classifiers_dict.values():
            for classifier in classifiers:
                test_samples += classifier.testing_samples

        # Remove duplicates while preserving order
        # This is the most efficient way to do it that I could find
        test_samples = list(dict.fromkeys(test_samples))

        for sample in test_samples:
            true_family = sample.family
            true_idx = family_to_idx[true_family]
            votes = Counter()

            # get predictions from all classifiers
            for classifier in self.classifiers:
                prediction = classifier.classify_string(sample)

                if not prediction:
                    continue

                votes[prediction] += 1

            # get the most voted family
            most_voted = votes.most_common(1)[0][0]
            most_voted_idx = family_to_idx[most_voted]

            # increment the confusion matrix
            matrix[true_idx][most_voted_idx] += 1

        # normalize the confusion matrix, keeping the dimensions
        row_sums = matrix.sum(axis=1, keepdims=True)
        matrix = np.divide(matrix, row_sums, where=row_sums!=0)

        self.matrix = matrix

        
    def present_confusion_matrix(self):
        '''
        Prints the confusion matrix for the top N families and saves a graph.
        '''
        pass

class OneVSOne(MultiClassClassifier):
    '''
    Class for One-vs-One technique.\n
    '''
    def __init__(self, *args, **kwargs):
        super(OneVSOne, self).__init__(*args, **kwargs)

        self.name = 'One-vs-One'
        self.train(**kwargs)
        self.confusion_matrix()

    def train(self,**kwargs):
        '''
        Trains the models for the One-vs-One technique.\n
        @params:\n
        \tkwargs: dictionary the hyperparameters
        '''

        if not (self.storage and self.storage.possible_families_dict):
            return None
        
        all_classes = self.storage.possible_families_dict

        # sort families by count
        local_top_families = sorted(all_classes.items(), # in all the items 
                              key=lambda x: x[1], # use count (second element) as sorting key
                              reverse=True) # descending order
        self.top_families  = [item[0] for item in local_top_families[:self.top_N]] # crop to top N
        print(f'Top families: {self.top_families}')

        # get all possible pairs
        class_pairs = list(combinations(self.top_families, 2))

        # iterate over the pairs and train the models
        for class1, class2 in class_pairs:
            classifier = self.model(self.storage, class1, class2, self.training_percentage, **kwargs)
            
            if not classifier:
                pass

            # append the classifier to the list of classifiers appropriate for each class
            if self.classifiers_dict.get(class1):
                self.classifiers_dict[class1].append(classifier)
            else:
                self.classifiers_dict[class1] = [classifier]
            if self.classifiers_dict.get(class2):
                self.classifiers_dict[class2].append(classifier)
            else:
                self.classifiers_dict[class2] = [classifier]

            self.classifiers.append(classifier)
import itertools
import time
import classifiers
import multiclass

def hyperparameter_tuning(storage, hyperparams_grid):
    '''
    Tries each combination of parameters to see which one gets the best results
    @param:
        storage: storage object with samples
        hyperparams_grid: grid with all the values to be tested 
        
    @returns:
        list of results containing epochs, lr, c, accuracy and training time
    '''
    # Create a list with all the possible hyperparameters
    hyperparam_combinations = list(itertools.product(
        hyperparams_grid['epochs'],
        hyperparams_grid['lr'],
        hyperparams_grid['c']
    ))

    # List for keeping the results
    results = []

    # Calculate the total combinations and start the counter for current combinations
    total_combinations = len(hyperparam_combinations)
    current_combination = 1

    training_percentage = 0.8 # Percentage of samples to be used in training

    # For each epoch, lr and c combination, create a test SVM and record the accuracy and training time
    for epochs, lr, c in itertools.product(hyperparams_grid['epochs'], hyperparams_grid['lr'], hyperparams_grid['c']):
        remaining = total_combinations - current_combination
        print(f"Testing combination {current_combination}/{total_combinations} " f"(remaining: {remaining}). Epochs: {epochs}, LR: {lr}, C: {c}")

        # Make a test instance of the SVM with the current loop of hyperparameters
        test_instance = classifiers.SVM(storage, 'malware', 'benign', training_percentage, e=epochs, lr=lr, c=c)

        # Start of training
        start_time = time.time()
        test_instance.train(e=epochs, lr=lr, c=c)
        training_time = time.time() - start_time

        # Test the SVM 
        accuracy = test_instance.test()

        # Add this round of results to the final tally
        results.append({
            'epochs': epochs,
            'lr': lr,
            'c': c,
            'accuracy': accuracy,
            'training_time': training_time
        })

        current_combination += 1

    return results

def single_SVM(feature_vectors, families):
    storage = classifiers.Storage(feature_vectors, families, 5560, 5560)
    classifier = classifiers.SVM(storage, 'malware', 'benign', 0.8)
    classifier.test()
    classifier.show_feature_importance()

def ovo(feature_vectors, families):
    storage = classifiers.Storage(feature_vectors, families, 0, 5560)
    # Empty for all possible malware families
    target_classes = []

    print('Training One-Vs-One SVM classifier')
    classifier = multiclass.OneVsOne(storage, classifiers.SVM, target_classes, 0.8, 20, kwargs={'e':10})
    classifier.present_confusion_matrix()

def ova(feature_vectors, families):
    storage = classifiers.Storage(feature_vectors, families, 0, 5560)
    # Empty for all possible malware families
    target_classes = []

    print('Training One-Vs-All SVM classifier')
    classifier = multiclass.OneVsAll(storage, classifiers.SVM, target_classes, 0.8, 5, kwargs={'e':10})
    classifier.present_confusion_matrix()

def main():
    '''
    Uncomment the method that you want to run
    '''

    feature_vectors = 'malware_classification/corpus/feature_vectors.zip'
    families = 'malware_classification/corpus/sha256_family.csv'

    # single_SVM(feature_vectors, families)
    # ovo(feature_vectors, families)
    # ova(feature_vectors, families)
    hyperparameter_tuning(classifiers.Storage(feature_vectors, families, 500, 500), {'epochs': [5, 10, 15], 'lr': [0.0001, 0.001], 'c': [1, 0.001, 0.01, 0.1]})

if __name__ == '__main__':
    main()
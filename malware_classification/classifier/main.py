import classifiers
import multiclass
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.cm import get_cmap
import random
import time

# Usage: Creating scatter plots
# Verification: The plots look good

def create_performance_scatter_plot(storage, save_path=None):
    """
    Creates scatter plots showing SVM performance with different hyperparameters.
    Highlights the top 5 performing configurations with unique colors.
    """
    print("Creating performance scatter plot...")
    
    # Define parameter ranges to test
    c_values = [0.0001, 0.0003, 0.0006, 0.0010, 0.0020]
    lr_values = [0.0005, 0.001, 0.002]
    decay_values = [0.2, 0.3, 0.4, 0.5]
    epoch_values = [5, 10, 15]
    
    # Record start time for dramatic effect
    start_time = time.time()
    
    # Store results
    results = []
    
    # Test various combinations (limit to ~15 for reasonable runtime)
    param_combinations = []
    
    # Generate combinations systematically to cover parameter space
    for c in c_values[:3]:
        for lr in lr_values[:2]:
            for decay in decay_values[:2]:
                for e in epoch_values[:2]:
                    param_combinations.append({
                        'early_stop': True,
                        'e': e,
                        'c': np.float64(c),
                        'lr': np.float64(lr),
                        'decay': np.float64(decay)
                    })
    
    # Add a few random combinations for diversity
    for _ in range(3):
        random_params = {
            'early_stop': True,
            'e': random.choice(epoch_values),
            'c': np.float64(random.choice(c_values)),
            'lr': np.float64(random.choice(lr_values)),
            'decay': np.float64(random.choice(decay_values))
        }
        if random_params not in param_combinations:
            param_combinations.append(random_params)
    
    # Train models with different parameters
    for i, params in enumerate(param_combinations):
        print(f"Training model {i+1}/{len(param_combinations)}: {params}")
        
        # Train model with current parameters
        svm = classifiers.SVM(storage, 'malware', 'benign', 0.8, **params)
        accuracy = svm.test()
        
        # Store results
        results.append({
            'params': params,
            'accuracy': accuracy,
            'c': params['c'],
            'lr': params['lr'],
            'decay': params['decay'],
            'epochs': params['e']
        })
        
        print(f"Accuracy: {accuracy:.4f}")
    
    # Sort results by accuracy (highest first)
    results.sort(key=lambda x: x['accuracy'], reverse=True)
    
    # Create figure with multiple subplots
    fig, axs = plt.subplots(2, 2, figsize=(14, 12))
    fig.suptitle('SVM Performance with Different Hyperparameters', fontsize=16)
    
    # Get a colormap for the top 5 performers
    cmap = get_cmap('viridis')
    top_colors = [cmap(i/5) for i in range(5)]
    
    # Create different scatter plots to visualize relationships
    plot_configs = [
        {'x': 'c', 'y': 'accuracy', 'title': 'Regularization (C) vs Accuracy', 'ax': axs[0, 0]},
        {'x': 'lr', 'y': 'accuracy', 'title': 'Learning Rate vs Accuracy', 'ax': axs[0, 1]},
        {'x': 'decay', 'y': 'accuracy', 'title': 'Learning Rate Decay vs Accuracy', 'ax': axs[1, 0]},
        {'x': 'epochs', 'y': 'accuracy', 'title': 'Epochs vs Accuracy', 'ax': axs[1, 1]}
    ]
    
    for plot_config in plot_configs:
        ax = plot_config['ax']
        
        # Plot all points with a standard color
        x_values = [result[plot_config['x']] for result in results]
        y_values = [result[plot_config['y']] for result in results]
        ax.scatter(x_values, y_values, color='gray', alpha=0.5, s=50)
        
        # Highlight top 5 performers with unique colors
        for i, result in enumerate(results[:5]):
            ax.scatter(result[plot_config['x']], result[plot_config['y']], 
                      color=top_colors[i], s=150, edgecolor='black', zorder=10,
                      label=f"Rank {i+1}: {result['accuracy']:.4f}")
        
        # Set labels and title
        ax.set_xlabel(plot_config['x'].replace('_', ' ').title())
        ax.set_ylabel('Accuracy')
        ax.set_title(plot_config['title'])
        ax.grid(True, linestyle='--', alpha=0.7)
        
        # Add a text box with the top parameters
        if plot_config['x'] == 'c':
            textstr = "\n".join([
                f"Top Result: {results[0]['accuracy']:.4f}",
                f"C: {results[0]['c']:.6f}",
                f"LR: {results[0]['lr']:.4f}",
                f"Decay: {results[0]['decay']:.2f}",
                f"Epochs: {results[0]['epochs']}"
            ])
            props = dict(boxstyle='round', facecolor='wheat', alpha=0.5)
            ax.text(0.05, 0.05, textstr, transform=ax.transAxes, fontsize=10,
                   verticalalignment='bottom', bbox=props)
    
    # Add legend to the last subplot
    handles, labels = axs[1, 1].get_legend_handles_labels()
    fig.legend(handles, labels, loc='lower center', ncol=5, bbox_to_anchor=(0.5, 0.01))
    
    # Add elapsed time for training
    elapsed_time = time.time() - start_time
    plt.figtext(0.5, 0.96, f"Total training time: {elapsed_time:.1f} seconds", 
                ha="center", fontsize=12, bbox={"facecolor":"orange", "alpha":0.5, "pad":5})
    
    plt.tight_layout(rect=[0, 0.03, 1, 0.95])
    
    # Save or show the plot
    if save_path:
        plt.savefig(save_path)
        print(f"Plot saved to {save_path}")
    else:
        plt.show()
    
    # Print top results
    print("\nTop 5 Parameter Combinations:")
    for i, result in enumerate(results[:5]):
        print(f"Rank {i+1}: Accuracy: {result['accuracy']:.4f}, Params: {result['params']}")
    
    return results

def main():
    feature_vectors = "malware_classification/corpus/feature_vectors.zip"
    families = "malware_classification/corpus/sha256_family.csv"
    save = "malware_classification/corpus/storage.pklrick"

    storage = classifiers.Storage(feature_vectors, families, 0, 5560)
    storage.save(save)
    #storage = classifiers.Storage.load(save)
    
    # Create performance scatter plot
    #create_performance_scatter_plot(storage, "malware_classification/corpus/svm_performance.png")
    
    #classifier = classifiers.SVM(storage, 'malware', 'benign', 0.8)
    #classifier.save(f'malware_classification/corpus/{classifier.name.replace(' ', '_')}.pklrick')
    #classifier.test()
    #classifier.show_feature_importance()

    # Empty for all possible malware families
    target_classes = []

    print("Training One-Vs-All SVM classifier")
    classifier = multiclass.OneVsAll(storage, classifiers.SVM, target_classes, 0.8, 20)
    classifier.present_confusion_matrix()

    #print("Training One-Vs-One SVM classifier")
    #classifier = multiclass.OneVsOne(storage, classifiers.SVM, target_classes, 0.8, 20)
    #classifier.present_confusion_matrix()

    #create_performance_scatter_plot(storage, "malware_classification/docs/")

if __name__ == "__main__":
    main()